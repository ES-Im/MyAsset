
# 도메인 모델
***

## 사용자(user)

---
## _Entity : user_
 
- 내부관리용 회원관련 비개인정보 엔티티 
####  Attribute

| 속성            | 설명         |
|---------------|------------|
| userKey        | 사용자의 내부식별자 |
| status        | 사용자 상태     | 
| role          | 관리자여부      | 
| creatAt       | 가입일자       | 
| lastLoginAt   | 마지막 로그인 일자 | 
| withdrawReqAt | 탈퇴요청일      |  

    ※ Enum : status
      · ACTIVE : 활성계정
      · WITHDRAWN : 탈퇴
      · WITHDRAW_PENDING : 탈퇴요청
      · DORMANT : 휴먼계정
    
    ※ Enum : role
      · ADMIN : 관리자
      · USER : 일반 사용자

    ※ userKey = 'default' 인 유저는 시스템 계정이며, 카테고리와 알람에 대해 유저가 커스텀하지 않을 시 해당 계정의 정책을 따른다. 즉, category와 notification에 대한 시스템 디폴트 설정

### 행위
    - constructor(): 회원등록 (status=ACTIVE, role=USER)
    - register() : 회원등록
    - requestWithdraw(): 사용자의 회원탈퇴요청 
    - requestActive() : 사용자의 계정복구요청
    - markDormant() : 휴먼계정전환
    - markWithdraw() : 탈퇴계정전환
    - validateDelete() : USER 물리적 삭제 가능 여부 판단
    - isActive() : 활설 계정 체크

### 정책 (Batch / Scheduler)
    - markDormant: 휴먼상태변경 
    - markWithdrawn: 회원탈퇴 상태 전환 
    - deleteUser: USER 정보 물리적 삭제 

### 규칙
    ① status 변환시점
      · ACTIVE : 소셜 회원가입 즉시
      · ACTIVE → DORMANT : 1년간 미접속
      · ACTIVE → WITHDRAW_PENDING : 사용자 탈퇴요청
      · WITHDRAW_PENDING / DORMANT → ACTIVE : 소셜로그인 && 사용자 동의
      · WITHDRAW_PENDING → WITHDRAWN : 사용자 탈퇴요청 후 30일 경과
      · WITHDRAW → 물리삭제 : 탈퇴 확정 후 60일 경과

    ② 회원탈퇴 (userInfoCleanByWithdrawn)
      · 사용자는 ACTIVE상태에서 회원을 탈퇴(요청)할 수 있다.
      · WITHDRAWN 상태전환 후 60일이 지나면 해당 유저에 대한 정보(E.user) 전부 물리적으로 삭제된다.
    
    ③ 계정복구
      · 사용자가 계정복구를 요청하면 즉시 Active 상태가 된다
      · WITHDRAW_PENDING 상태에서 계정을 복구하면 '탈퇴요청일자'가 Null값이 된다. 

     

### _Entity : user_info_

- OAuth로 불러온 회원관련 개인정보 엔티티
#### Attribute
| 속성           | 설명                    |
|--------------|-----------------------|
| userKey      | 사용자의 내부식별자            |
| name         | 사용자 이름 (소셜서버에서 받은 값)  |
| email        | 사용자 이메일 (소셜서버에서 받은 값) |
| providerType | OAuth 서비스 Provider    |

    ※ Enum : providerType
      · KAKAO
      · GOOGLE
      · NAVER

    ※ userKey = 'default' 인 유저는 시스템 계정이며, 카테고리와 알람에 대해 유저가 커스텀하지 않을 시 해당 계정의 정책을 따른다. 즉, category와 notification에 대한 시스템 디폴트 설정

### 행위
    - constructor(): 회원정보 저장
    - registerFromOAuth() : 회원 정보 등록

### 정책 (Batch / Scheduler)
    - deleteUserInfo: 회원의 개인정보 물리적으로 삭제 

### 도메인간 관계 정의
    - USER (1) --- (0..1) USER_INFO
    - User는 Aggregate Root이며, UserInfo는 User의 생명주기에 종속된다.
    User가 WITHDRAWN 상태로 전환되면 해당 User의 개인정보(UserInfo)는 정책에 따라 일정 시간이 지난 후 제거된다.

    ※ user과 userInfo 생명주기  - 삭제예정 문구 (개인 참고용)
    - 생성 : OAuthUserInfo(불변 DTO) → userInfo 생성 → user 생성
    - 소멸 : user WITHDRAWN 전환 → userInfo 소멸 -(60일뒤)→ user 소멸 



---

## 자산 (Asset)
    - 사용자가 보유한 자산종목
**Entity: Aggregate root**

| 속성            | 설명                             |
|---------------|--------------------------------|
| assetId       | 자산 내부식별자                       |
| user_key      | 사용자의 내부식별자(asset:user = N:1)   | 
| assetType     | 자산 종류                          | 

    ※ Enum : assetType
      · CARD : 체크카드, 신용카드
      · STOCK_ACCOUNT : 증권계좌
      · BANK_ACCOUNT : 예금계좌
      · CASH : 현금

### 행위
    - addCashAsset() : 현금 자산 추가

    [application layer에서 정의함, AssertType.ismanualType() / .isSyncType()으로 체크]
    - updateCashAsset() : 현금 자산 수정
    - removeCashAsset() : 현금 자산 삭제
    - syncAssets() : 자산동기화 (card, stock_account, bank_account 갱신)

### 정책 
    - isEditable() : CASH 외에는 조회전용<br>
      → CASH외에는 동기화 대상

### 도메인간 관계 정의
    - Asset (1) --- (0..N) CARD
    - Asset (1) --- (0..N) STOCK_ACCOUNT
    - Asset (1) --- (0..N) BANK_ACCOUNT
    - Asset (1) --- (0..1) CASH

## 은행계좌(bankAccount)
**entity**

| 속성             | 설명                                 |
|----------------|------------------------------------|
| bankAcctId     | 은행계좌 내부식별자                         |
| asset_id       | 자산의 내부식별자(bankAccount:asset = N:1) |
| bankCode       | 은행코드(CompanyCode)                  |
| acctNum        | 계좌 번호                              |
| balance        | 계좌 잔액                              |

    ※ Enum : bankCode(CompanyCode)
      · 금융결제원 공시 기관 코드 기준 금융 기관 코드

## 현금(cash)
**entity**

| 속성            | 설명                             |
|---------------|--------------------------------|
| cashId       | 현금장부 내부식별자                       |
| asset_id      | 자산의 내부식별자(cash:asset = N:1)   |
| balance     | 현금 잔액                        |

## 카드(Card)
**entity**

| 속성           | 설명                          |
|--------------|-----------------------------|
| cardId       | 카드 내부식별자                    |
| asset_id     | 자산의 내부식별자(Card:asset = N:1) |
| cardCode     | 카드사 코드                      |
| cardType     | 카드 유형                       |
| billingDay   | 결제일                         |
| bankAccount  | 인출 계좌번호(미연결 계좌 시 null)      |

    ※ Enum : cardCode
      · 금융결제원 공시 기관 코드 기준 카드사 기관 코드

    ※ Enum : cardType
      · 체크카드(debit)
      · 신용카드(credit)

## 카드월이용액(CardMonth)
**entity**

| 속성              | 설명                     |
|-----------------|------------------------|
| cardMthId       | 내부식별자                  |
| cardId          | 카드 내부식별자               |
| billingMth        | 대상 월                   |
| mthUsedAmt        | 총 이용액                  |

### 행위

    - createNewCardMonth() : 새로운 cardMonth 엔티티를 생성한다.
    - addUsedMthAmt() : 카드 사용 시, 해당 카드와 월의 cardMonth에 총 이용액에 포함한다.

### 정책 
    - createForNewMonth() : 매월 1일 새로운 CardMonth가 생성된다
    - initForCardMonth() : 처음으로 동기화하는 카드에 대해 CardMonth를 생성한다.
        - 신규회원의 경우는 과거 카드 승인 내역은 무시하고, mthUsedAmt를 0부터 시작한다.
        - 위 사항을 사용자에게 알리는 문구를 사용자에게 알린다. ("동기화 이전 사용내역은 조회되지 않습니다")


## 증권계좌(stockAccount)
**entity**

| 속성          | 설명                                  |
|-------------|-------------------------------------|
| stockAcctId | 증권계좌 내부식별자                          |
| asset_id    | 자산의 내부식별자(stockAccount:asset = N:1) |
| acct_num    | 계좌번호                                |
| brokerCode  | 증권사코드(CompanyCode)                  |

    ※ Enum : bankCode(CompanyCode)
      · 금융결제원 공시 기관 코드 기준 금융 기관 코드

---

## 거래내역(transactions)
**entity**

| 속성              | 설명                                  |
|-----------------|-------------------------------------|
| tran_id         | 거래내역 내부식별자                          |
| asset_id        | 자산의 내부식별자(transactions:asset = N:1) |
| cgy_id          | 카테고리 내부식별자                          |
| flowType        | 자산 유입 / 유출                          |
| payStatus       | 결제 수단                               |
| tranAmt         | 거래 금액                               |
| totalInstallCnt | 할부회차                                |
| memo            | 거래에 대한 사용자 메모                       |

    ※ Enum : payStatus(거래 승인상태)
      · APPROVED("01", "승인"),
      · CANCELLED("02", "승인취소")
      · CORRECTED("03", "정정")
      · NO_AUTH("04", "무승인매입")

    ※ Enum : flowType 
      · INFLOW 자산 유입 
      · OUTFLOW 자산 유출

### 행위
    - createTransaction()
    - updateTransaction()
    - checkDeleteTransaction()

### 정책

    - transactionClean<br>
     : 사용자가 WITHDRAWN 상태 전환 후 60일이 지나면 해당 유저에 대한 거래내역이 전부 물리적으로 삭제된다.

### 규칙
    - isPositive() : 입력된 값은 양수여야한다.
    - isFuture() : 입력된 날은 미래가 될 수 없다.
    - checkEditablePayType() : 메모 제외 현금만 직접 수정이 가능하다.   → assetType : isManualType
    - 

### 도메인간 관계 정의
    - Transactions (1) --- (0..N) TransactionFile
    - Transactions (1..N) --- (1) CATEGORY
    - Transactions (1..N) --- (1) ASSET

## 거래내역 첨부파일 (transactionFile)
| 속성                  | 설명                                             |
|---------------------|------------------------------------------------|
| file_Id             | 거래내역 첨부파일 내부식별자                                |
| tran_id             | 거래내역 내부식별자(transactionFile:transactions = N:1) |
| sourceFileName      | 원본 파일명                                         |
| destinationFileName | 저장되는 파일 명(UUID 조합)                             |
| ext                 | 파일 확장자 명                                       |
| size                | 파일 크기                                          |

    ※ Enum : EXT 
      · 허용가능한 확장자 명 
      · JPG
      · PNG
      · JPEG
      · GIF
      · WEBP


### 규칙
    - checkExt() : 허용한 확장자인지 검토
    - checkSize() : 10MB 이하인지 검토    // webapi - layer에 예외로 

### 정책
    - checkTranFileCleanByDeleteTran() : 거래를 삭제하면 하위의 첨부파일도 삭제된다


### 예산(budget)

*entity*

| 속성             | 설명                            |
|----------------|-------------------------------|
| budget_Id      | 예산 내부식별자                      |
| user_key       | 사용자의 내부식별자(budget:user = N:1) |
| year           | 대상 연                          |
| month          | 대상 월                          |
| expenseType    | 대상 지출 타입 (변동/고정/적금)           |
| amt            | 예산 지출액                        |
| monthly_income | 회원의 월소득액                      |

    ※ Enum : ExpenseType
        -  FIXED(고정지출), VARIABLE(변동지출), INSTALLMENT_SAVINGS(적금)

### 행위
    - createBudget() : 회원의 월 소득액을 기반 + budget_rule 정책에 따라 예산을 정의한다
    - recalculateBudgetByRule() : budget_rule이 바꾸면 그 정책대로 예산을 바꾼다.
    - updateMonthlyIncome() : 회원의 월 소득액을 변경한다

### 정책
    - 한 회원(user_key)의 특정 연(year)-월(month)의 예산 객체는 expenseType의 속성 갯수만큼 만들어진다. <br>
    즉, user A의 2026년 1월 예산을 만들기 위해선 budget entity가 expenseType 별로 여러개 만들어진다.
    - unEditable() : 과거의 예산을 수정할 수 없다.
    - 예산은 monthly_income을 기준으로 계산된다.

### 규칙
    - isPositive() : 월소득액과 예산지출액은 양수이다.
    - checkDuplicate() : 둘 이상의 (user_key, year, month, expenseType) 인 예산은 생성할 수 없다.
    

## 예산설정(budget_rule)

*entity*

| 속성          | 설명                                            |
|-------------|-----------------------------------------------|
| bgt_Rule_Id | 예산설정 내부식별자                                    |
| user_key    | 사용자의 내부식별자(budget_rule:user = N:1) 기본값이면 null |
| expenseType | 대상 지출 타입 (변동/고정/적금)                           |
| ValueType   | bgyParam이 금액인지 비율인지 표시한다.                     |
| bgtParam    | ValueType에 따라 금액인지 비율인지를 표시한다.                |

    ※ ENUM : ExpenseType
        - FIXED(고정지출), VARIABLE(변동지출), INSTALLMENT_SAVINGS(적금)
    ※ ENUM : ValueType → bgyParam 값을 정의한다.
        - AMOUNT : 금액 기준 → bgyParam = expenseType에 설정된 예산
        - RATIO : 비율 기준 → bgyParam = 월 소득액 대비 expenseType을 얼마로 둘건지를 설정한다.

### 행위
    - applyRuleToBudget() : valueType에 따라 bgtParam 속성이 달라지며 이를 토대로 예산이 계산이 된다.
    - changeRule() : 사용자가 예산 설정을 변경
    - resetRule() : 사용자가 설정한 설정을 삭제한다 (default rule로 변경)

### 정책
    - user_key = null 인 budgetRule이 예산 계산시 기본 rule이다.
    - user_key != null 이면 기본 budgetRule보다 우선 적용된다.
    - BudgetRule은 과거 budget에 영향을 주지 않는다.

### 규칙
    - checkRatioExpense() : value_type이 RATIO일 경우, 한 회원의 특정 연월의 expenseType 비율의 합은 100이다.
    - checkAmountExpense() : value_type이 AMOUNT일 경우, bgtParam은 0보다 크다.
    - 한 회원의 expenseType은 하나만 존재한다.

### 카테고리(category)
**entity**

| 속성          | 설명                                                                    |
|-------------|-----------------------------------------------------------------------|
| cgv_id      | 카테고리 설정 내부식별자                                                         |
| user_key    | 사용자의 내부식별자(category:user = N:1) "userKey = default"이면 시스템 디폴트 카테고리 사용 |
| cgyName     | 세부 지출 카테고리 - 주거관리비, 보험, 구독비, 교통비, 통신비, 식비, 생활비, 여가기타                  |
| expenseType | 대상 지출 타입 (변동/고정/적금)                                                   |
| isActive    | 디폴트 = true / false시 해당 카테고리를 숨긴다.                                     |

    ※ Enum : ExpenseType
        -  FIXED(고정지출), VARIABLE(변동지출), INSTALLMENT_SAVINGS(적금)

### 행위
    - createCategory() : 사용자 커스텀 카테고리를 생성한다.
    - updateCgyName() : 카테고리 이름(cgyType)을 변경한다
    - activateCgv() : 카테고리를 활성화 한다.
    - deActivateCgv() : 카테고리를 숨긴다.
    - checkCgvCleanByDeleteUser() : 유저계정정보가 삭제될시 해당 사용자 커스텀 카테고리 삭제여부 확인

### 정책
    - 사용자는 category는 생성, 수정, 숨기기만 가능하며 물리적으로 삭제할 수 없다.
    - user의 탈퇴시, 배치처리로 해당유저의 커스텀 category를 삭제한다.
    - 숨긴 category는 신규 거래 등록/수정 시 선택할 수 없다.
    - category는 반드시 cgyType expenseType을 하나씩 가진다.
    - 사용자 커스텀 카테고리가 디폴트 카테고리보다 우선한다.
    - 지출타입(expenseType) 변경은 이미 거래가 있는 경우 제한된다.

### 규칙
    - cgyName은 공백이 될 수 없다.
    - 한 user의 커스텀 카테고리는 중복 cgyName을 가질 수 없다

## 알림(notification)
---

**entity**

| 속성       | 설명                                                |
|----------|---------------------------------------------------|
| noti_Id  | 알림 내부 식별자                                         |
| user_key | 사용자의 내부식별자(notification:user = N:1)               |
| is_Read  | 사용자의 알림확인 여부 (default : false)                    |
| is_hide  | 사용자의 알림히스토리에 보이기(false)/숨기기(true) (default:false) |
| sent_At  | 알림발송시각                                            |

### 행위
    - markRead() : 읽음표시로 바꾼다.
    - markHide() : 알림히스토리에서 삭제한다(물리적 삭제 x), is_hide → false

### 정책
    - notification은 수정되지 않는다.
    - validateDelete() : sendAt기준 90일이 지났는지 확인 (90일이 지나면 자동 정리 대상)
    - isRead = true 인 알림은 읽지 않은 알림 수(unread count) 계산에서 제외된다.
    - deletedAt 이 존재하는 알림은 사용자 알림 목록 조회 대상에서 제외된다.
    - isRead = true 라면 UX에서 알림표시 count에서 제외된다
    - isHide = true 인 알림은 조회되지 않는다.


### 규칙

## 알림규칙(notification_rule)
**entity**
 - user_key != null 인 것 : notiType에 대해서 유저가 알림 비활성화 한 것
 - user_key = null 인 것 : 시스템 디폴트 규칙. 

| 속성           | 설명                                                               |
|--------------|------------------------------------------------------------------|
| noti_Rule_Id | 알림 내부 식별자                                                        |
| user_key     | 사용자의 내부식별자(alarm:user = N:1) userKey = default는 시스템 디폴트 설정을 뜻함   |
| notiType     | 알림원인                                                             |

    ※ ENUM : notiType(NotificationType)
        - BUDGET_EXCEEDED : 월 예산 초과
        - DAILY_SPEND_SUMMARY : 일일 지출 요약
        - WEEKLY_SPEND_SUMMARY : 주간 지출 요약
        - MONTHLY_SPEND_SUMMARY : 월간 지출 요약
        - CARD_PAYMENT_DUE : 카드 결제일 도래 1일 전
        - STOCK_PRICE_SURGE : 보유 주식 급등
        - STOCK_PRICE_DROP : 보유 주식 급락
        - ABNORMAL_REPEATED_TRANSACTION : 비정상적인 동일 지출 (5분내 3회 반복)
        - ABNORMAL_EXPENSE : 예산의 30% 이상 지출건

### 행위
    -  public static NotificationRule deactivate() : 알림규칙 활성화. Notification 엔티티를 생성한다.
    - deActive() : 알림규칙 비활성화. Notification 엔티티를 삭제한다. (delete)

### 정책
    - user_key = null : 알림규칙의 시스템 디폴트 규칙 모든 알림은 기본적으로 활성화 상태이다. 
    - user_key != null : 알림규칙의 사용자 커스텀 규칙. 유저는 특정 알림에 대해서 알림 비활성화 할 수 있다.
    - 사용자 커스텀 규칙이 존재하면, 시스템 디폴트 규칙보다 우선된다.
        " 알림 생성 시점에, 해당 사용자 + notiType에 대한 NotificationRule이 
        존재하면 → 알림을 생성하지 않는다.
        존재하지 않으면  → 알림을 생성한다"

### 규칙
    - 사용자 별 notiType은 하나이다



## 자산 포트폴리오

---
## 월별 지출요약 (user_monthly_summary)

**entity**

| 속성                       | 설명                             |
|--------------------------|--------------------------------|
| summary_Id               | 월별 지출요약 내부식별자                  |
| user_key                 | 사용자의 내부식별자(alarm:user = N:1)   |
| year                     | 대상 연                           |
| month                    | 대상 월                           |
| fixed_Spent              | 고정 지출 합계                       |
| variable_Spent           | 변동 지출 합계                       |
| avg_Daily_Variable_Spent | 변동비 일일 지출 평균                   |
| total_Spent              | 총 지출 액                         |

### 행위

### 정책
    - 사용자의 당월 지출요약은 매일 새벽에 갱신화 되며, 기준은 어제자이다. 
        - 매일 새벽 00:05에 당월의 지출요약을 재계산한다.
        - 재계산된 데이터는 즉시 반영된다.
    - 사용자는 해당 데이터를 수정/삭제/생성 할 수 없다.

### 규칙
    - fixed_spent, variable_spent, avg_daily_variable_spent, total_spent는 0또는 양수이다.
    - total_spent는 fixed_spent + variable_spent이다.
    - avg_daily_variable_spent = (당월의) 전날까지의 누적 변동 지출 금액 / 전날까지 변동 지출이 발생한 일수 

## 월별 카테고리별 지출 요약(user_monthly_detail)

**entity**

| 속성           | 설명                                                            |
|--------------|---------------------------------------------------------------|
| detail_Id    | 카테고리별 지출 요약 내부 식별자                                            |
| summary_id   | 월별 지출요약 내부식별자(user_monthly_detail:user_monthly_summary = N:1) |
| expense_Type | (Enum) 지출 카테고리                                                |
| avg_Spent    | 카테고리별 월별 평균 지출액                                               |
| total_Spent  | 카테고리별 월별 총 지출액                                                |

### 행위

### 정책
    - user_monthly_detail는 user_monthly_summary가 갱신화될때 같이 갱신화된다.

### 규칙
    - 동일 summary_id의 total_spent의 합은 해당 user_monthly_summary 테이블의 summary_id의 total_spent와 같다
    - 세부 변동지출의 합은 user_monthly_summary의 변동지출합계와 같다
    - 고정 변동지출의 합은 user_monthly_summary의 고정지출합계와 같다.
    - avg_Spent = total_Spent / 타겟 일의 해당 카테고리 지출 건수의 합


## to-do 증권계좌 및 주식 도메인 모델 설계 

### 보유주식종목(Holding)
**entity**

### 주식종목뉴스(news)
**entity**


